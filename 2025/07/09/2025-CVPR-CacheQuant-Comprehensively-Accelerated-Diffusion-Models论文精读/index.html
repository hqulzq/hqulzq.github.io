<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hqulzq.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="全文翻译摘要扩散模型在图像合成领域逐渐崭露头角，展现出卓越的生成能力。然而，由于时间和结构层面的冗余导致推理速度缓慢且网络复杂，阻碍了其在现实场景中的低延迟应用。当前针对扩散模型的加速方法分别聚焦于时间层面和结构层面。但在每个层面进行独立优化以进一步突破加速极限时，会导致性能显著下降。另一方面，整合两个层面的优化可以增强加速效果。遗憾的是，我们发现这两个层面的优化并非完全正交。先进行单独优化再简单">
<meta property="og:type" content="article">
<meta property="og:title" content="2025-CVPR-CacheQuant Comprehensively Accelerated Diffusion Models论文精读">
<meta property="og:url" content="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/index.html">
<meta property="og:site_name" content="Lzq&#39;s blog">
<meta property="og:description" content="全文翻译摘要扩散模型在图像合成领域逐渐崭露头角，展现出卓越的生成能力。然而，由于时间和结构层面的冗余导致推理速度缓慢且网络复杂，阻碍了其在现实场景中的低延迟应用。当前针对扩散模型的加速方法分别聚焦于时间层面和结构层面。但在每个层面进行独立优化以进一步突破加速极限时，会导致性能显著下降。另一方面，整合两个层面的优化可以增强加速效果。遗憾的是，我们发现这两个层面的优化并非完全正交。先进行单独优化再简单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/f1.png">
<meta property="og:image" content="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/f2.png">
<meta property="og:image" content="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/a1.png">
<meta property="article:published_time" content="2025-07-09T14:46:30.000Z">
<meta property="article:modified_time" content="2025-07-10T13:07:20.576Z">
<meta property="article:author" content="Zongqing Li">
<meta property="article:tag" content="diffusion">
<meta property="article:tag" content="CVPR">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/f1.png">

<link rel="canonical" href="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2025-CVPR-CacheQuant Comprehensively Accelerated Diffusion Models论文精读 | Lzq's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lzq's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">100</span></a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book" rel="section"><i class="fas fa-book fa-fw"></i>Book</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hqulzq.github.io/2025/07/09/2025-CVPR-CacheQuant-Comprehensively-Accelerated-Diffusion-Models%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://github.com/hqulzq/hqulzq.github.io/blob/main/images/userimg.jpg?raw=true">
      <meta itemprop="name" content="Zongqing Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lzq's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2025-CVPR-CacheQuant Comprehensively Accelerated Diffusion Models论文精读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-09 22:46:30" itemprop="dateCreated datePublished" datetime="2025-07-09T22:46:30+08:00">2025-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-10 21:07:20" itemprop="dateModified" datetime="2025-07-10T21:07:20+08:00">2025-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="全文翻译"><a href="#全文翻译" class="headerlink" title="全文翻译"></a>全文翻译</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>扩散模型在图像合成领域逐渐崭露头角，展现出卓越的生成能力。然而，由于时间和结构层面的冗余导致推理速度缓慢且网络复杂，阻碍了其在现实场景中的低延迟应用。当前针对扩散模型的加速方法分别聚焦于时间层面和结构层面。但在每个层面进行独立优化以进一步突破加速极限时，会导致性能显著下降。另一方面，整合两个层面的优化可以增强加速效果。遗憾的是，我们发现这<strong>两个层面的优化并非完全正交</strong>。先进行单独优化再简单整合，会导致性能不理想。<strong>为解决这一问题，我们提出了CacheQuant，这是一种全新的无训练范式，通过联合优化模型缓存和量化技术来全面加速扩散模型。具体而言，我们采用动态规划方法确定最优缓存调度，其中仔细考虑了缓存和量化的特性，以最小化误差。此外，我们提出解耦误差校正，逐步减轻耦合和累积的误差。</strong>实验结果表明，在MS-COCO数据集上，CacheQuant对Stable Diffusion实现了5.18倍的加速和4倍的压缩，而CLIP分数仅下降0.02。我们的代码已开源。</p>
<span id="more"></span>
<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>近年来，基于不同框架（如UNet [57] 和DiT [53]）的扩散模型 [7, 19, 69] 已在图像合成领域占据主导地位，展现出卓越的生成能力。扩散模型已被应用于众多令人瞩目的场景，包括但不限于图像编辑 [2, 20, 45]、图像增强 [10, 24, 60]、图像到图像的转换 [5, 58, 70]、文本到图像生成 [50, 55, 59, 79] 以及文本到3D生成 [33, 42, 54]。尽管扩散模型极具吸引力，但由于其需要数千次去噪迭代且包含数十亿模型参数，导致推理速度缓慢且网络结构复杂，这给其在实际应用中的部署带来了重大挑战。例如，即使在高性能硬件A6000 GPU上，Stable Diffusion [56] 单次推理也需要超过一分钟的时间，并且消耗16GB内存。</p>
<p>为应对上述挑战，研究界主要从两个层面加速扩散模型：时间层面和结构层面。对于前者，现有方法 [26, 40, 46, 61, 68] 通过缩短去噪轨迹来解决推理速度慢的问题。相比之下，其他方法 [3, 9, 27, 37, 38] 则侧重于简化网络结构，以解决后者（网络复杂）的问题。尽管这些方法已取得显著成果，但各自都存在缺陷。<strong>如图1所示，时间层面的方法无法降低网络复杂度，甚至会加剧这一问题；而结构层面的方法则需要昂贵的再训练过程。此外，在每个层面独立优化以进一步突破加速极限（例如采用更短的去噪路径 [44] 或进一步减少模型参数 [71]）会导致性能显著下降。</strong>因此，我们致力于开发一种能在时间和结构两个层面全面加速扩散模型的解决方案，旨在整合各个层面的优势，同时消除其各自的缺陷。这样一来，我们就能在不影响性能的前提下，进一步突破加速极限。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="f1.png" width="50%"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>图 1. 动机概述。(a) 传统加速方法在各个层面的原理和特性。(b) 我们的方法整合了模型缓存和量化的优势，同时消除了它们的缺点，实现了两个层面的全面加速。</em></td>
</tr>
</tbody>
</table>
</div>
<p>我们首先分析了每个层面上方法的特性。<strong>在时间层面，模型缓存 [4, 65, 73] 利用缓存机制消除每一步的冗余计算，无需再训练，与其他方法 [8, 36, 51, 68, 80] 相比，在相同的计算预算内能够保持时间连续性和性能。在结构层面，与其他基于压缩的方法 [13, 28, 35, 63, 75] 相比，基于量化的方法 [15, 66] 在训练开销方面更高效，且更易于硬件实现。因此，我们选择模型缓存和量化来全面加速扩散模型。此外，这两种技术还具有协同作用：量化减少了缓存所增加的内存使用量，而缓存则缓解了由时间冗余导致的量化难题。</strong></p>
<p>基于上述分析，从理论上讲，将优化后的模型缓存与量化方法相结合，能够在实现更显著加速的同时，控制性能的下降幅度。然而，在实践中我们发现，这两种方法的优化并非完全正交。独立优化后再简单组合，会导致性能不理想。根本问题在于，缓存和量化都会给原始模型引入误差。这些误差会迭代地耦合和累积，进一步加剧对模型性能的影响，阻碍优化方法的有效整合。更具体地说，如果将模型量化直接应用于缓存方法，量化误差会导致缓存的去噪路径出现显著偏差；相反，如果将模型缓存直接添加到量化方法中，缓存误差会导致量化误差大量累积。在这两种情况下，模型性能都会严重下降。</p>
<p>为此，我们提出了CacheQuant，通过联合优化模型缓存和量化技术来解决上述问题。<strong>具体而言，我们提出了动态规划调度（DPS），将缓存调度的设计建模为动态规划问题，旨在最小化缓存和量化所引入的误差。</strong>通过优化，DPS的计算复杂度显著降低，在ImageNet上对LDM（潜在扩散模型）进行处理仅需8分钟。<strong>为了进一步减轻耦合和累积的误差，我们提出了解耦误差校正（DEC），它以无需训练的方式，在每个时间步分别对缓存误差和量化误差进行通道级校正。</strong>由于对量化误差的校正可以融入权重量化中，因此DEC在网络推理过程中仅额外引入一次矩阵乘法和加法运算。据我们所知，这是首个在时间和结构两个层面研究扩散模型加速的工作。我们还通过在各种硬件平台（GPU、CPU、ARM）上部署CacheQuant，评估了其加速能力。</p>
<p>综上所述，我们的贡献如下：</p>
<ul>
<li>我们提出了CacheQuant，这是一种新颖的无需训练的范式，能够在时间和结构两个层面全面加速不同框架的扩散模型。我们的方法进一步突破了加速极限，同时保持了性能。</li>
<li>CacheQuant通过DPS最小化来自缓存和量化的误差，并通过DEC进一步减轻这些误差。它通过联合优化模型缓存和量化技术，实现了两者的优势互补。</li>
<li>我们在采用UNet和DiT框架的扩散模型上进行了实验。大量实验表明，我们的方法在加速比和性能方面都优于传统的加速方法（求解器、缓存、蒸馏、剪枝、量化）。</li>
</ul>
<h3 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h3><p>扩散模型已逐渐超越生成对抗网络（GANs）[1, 12]和变分自编码器（VAEs）[18, 22]，成为图像生成领域的主导方法。然而，由于推理速度慢且网络结构复杂，它们在实际场景中的低延迟应用受到阻碍。当前研究主要从两个层面来加速扩散模型。</p>
<p>时间层面的加速方法侧重于缩短采样轨迹。一些方法通过调整方差调度[51]或修改去噪方程[68, 80]来完全移除某些步骤。研究进一步深入到随机微分方程（SDE）[8, 36]或常微分方程（ODE）[40, 41]的快速求解器，以创建高效的采样步骤。还有一些方法[25, 67, 81]通过并行采样来加快推理速度。相比之下，基于缓存的方法[4, 44, 73]通过缓存块的输出来减少每一步的推理路径。</p>
<p>结构层面的加速方法主要致力于简化网络架构。先前的研究重新设计了轻量级网络[28]，或将频率先验融入模型设计中[75]。OMS-DPM[35]创建了一个扩散模型库，以便在不同步骤选择不同的模型。一些方法[43, 46, 61]利用蒸馏技术简化模型架构。另一方面，基于剪枝的方法[3, 9, 78]减少模型参数数量，而基于量化的方法[27, 29, 30, 37, 38]通过使用低位宽表示实现模型压缩。</p>
<h3 id="3-预备知识"><a href="#3-预备知识" class="headerlink" title="3. 预备知识"></a>3. 预备知识</h3><p>下面，我们介绍本工作中采用的两项关键技术。</p>
<p>模型缓存通过存储网络的中间输出加速推理过程。对于具有时序网络的扩散模型，该技术利用相邻去噪步骤之间特征图的固有相似性，消除时间维度上的计算冗余。例如，我们将某一步骤t的块输出激活$X_{g}^{t}$缓存为$X_{c}^{t}$。在步骤$t+1$进行推理时，复用$X_{c}^{t}$来替代真实值$X_{g}^{t+1}$，从而省去$X_{g}^{t+1}$的计算过程。现有方法在不同的网络层实现缓存：Deepcache [44] 和 Faster Diffusion [26] 分别缓存上采样块和UNet编码器的输出特征图；Block Caching [73] 进一步自适应地缓存所有块；Δ-DiT [4] 则根据不同去噪阶段的影响，选择性地缓存块。此外，该机制可扩展到更多步骤，计算一次缓存特征$X_{c}^{t}$，并在后续的$N-1$个步骤中复用：</p>
<script type="math/tex; mode=display">X_{c}^{t} \to X_{g}^{t+1} \Rightarrow X_{c}^{t} \to\left\{X_{g}^{t+1}, X_{g}^{t+2}, ..., X_{g}^{t+N}\right\} \tag{1}</script><p>缓存调度的确定（即确定何时重新计算缓存特征）直接影响模型性能。例如，对于具有T个步骤的扩散模型，当缓存频率N固定时，均匀缓存调度可表示为$\{0, N, 2N, …, (T/N-1)N\}$，对应的缓存特征为$\{X_{c}^{0}, X_{c}^{N}, X_{c}^{2N}, …, X_{c}^{(T/N-1)N}\}$。为减少缓存引入的误差，现有方法设计了多种缓存调度：[4, 44, 73] 通过实验和超参数调优确定调度，[26] 则直接手动指定调度。<strong>在本工作中，如图2所示，对于UNet框架，我们借鉴DeepCache [44] 的方法，将单个上采样块的输出作为缓存特征$x_{c}$；对于DiT框架，参考Δ-DiT [4]，将两个块之间的偏差$\Delta_{c}$作为缓存特征。我们将调度选择建模为动态规划问题，目标是最小化缓存和量化引入的误差，从而获得最优调度。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="f2.png" width="100%"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>图2. CacheQuant概述。动态规划调度（DPS）选择最优缓存调度，解耦误差校正（DEC）减轻耦合和累积的误差。</em></td>
</tr>
</tbody>
</table>
</div>
<p>模型量化通过低精度整数值表示模型参数和激活值，实现模型压缩和推理加速。对于浮点向量x，其均匀量化过程如下：</p>
<script type="math/tex; mode=display">\hat{x} = clip\left(\lfloor x/s \rceil + z, 0, 2^b - 1\right) \tag{2}</script><p>其中，$\hat{x}$为量化后的值，s为缩放因子，z为零点，$\lfloor \cdot \rceil$表示取整函数，位宽b决定了裁剪函数$clip(\cdot)$的范围。根据是否需要对模型进行微调，该技术可分为两种：训练后量化（PTQ）和量化感知训练（QAT）。早期的PTQ方法 [31, 47] 利用小型校准集，以无需训练的方式校准量化参数；随后，基于重构的方法 [32, 48, 72] 通过反向传播优化量化参数。另一方面，QAT方法 [11, 49] 需要在原始数据集上微调模型权重，这种方法虽能保持性能，但需要大量的时间和计算资源。值得注意的是，现有扩散模型的量化方法要么基于重构 [27, 38]，要么基于微调 [14, 37]。与之形成鲜明对比的是，我们提出了一种PTQ校正策略来减轻误差，同时保留无需训练的优势。</p>
<h3 id="4-CacheQuant"><a href="#4-CacheQuant" class="headerlink" title="4. CacheQuant"></a>4. CacheQuant</h3><p>在本节中，我们将介绍CacheQuant，这是一种新颖的无训练范式，通过联合优化缓存和量化技术来全面加速扩散模型。我们首先在4.1节分析综合加速面临的挑战，然后在4.2节和4.3节中提出解决这些挑战的方法。CacheQuant的概述如图2所示。</p>
<h4 id="4-1-综合加速的挑战"><a href="#4-1-综合加速的挑战" class="headerlink" title="4.1. 综合加速的挑战"></a>4.1. 综合加速的挑战</h4><p>利用模型缓存和量化可以实现扩散模型的综合加速。不幸的是，我们发现，尽管对这两种方法分别进行优化然后简单整合能带来更显著的加速，但模型性能却远不能令人满意。为了分析上述问题，我们在ImageNet上对LDM进行了实验。如图3所示，当对原始模型分别进行模型量化和缓存优化时，FID分数分别下降了0.76和4.71。然而，简单地将这两种优化结合起来，会导致FID损失达到11.99。根本问题在于，缓存和量化本质上都会给原始模型带来误差。这些误差会迭代地耦合和累积，进一步加剧对模型性能的影响，阻碍优化方法的有效结合。如图4所示，如果将模型量化直接应用于缓存方法，量化误差会导致缓存的去噪路径出现显著偏差；相反，如果将模型缓存直接应用于量化方法，缓存误差会导致量化误差大量累积。这表明这两种方法的优化并非完全正交，因此需要进行联合优化。</p>
<h4 id="4-2-动态规划调度"><a href="#4-2-动态规划调度" class="headerlink" title="4.2. 动态规划调度"></a>4.2. 动态规划调度</h4><p>我们以UNet框架为例来说明我们的方法。为了最小化误差，我们分析所有步骤的特征图$X = \{X_{g}^{0}, X_{g}^{1}, …, X_{g}^{T-1}\}$，以指导缓存调度的选择，并将该问题重新定义为有序样本的分组问题。</p>
<p>对于一个具有T个步骤和缓存频率N的扩散模型，所有特征图被分为$K = T/N$个组，形成一个分组集合$G = \{G_{1}, G_{2}, …, G_{K}\}$。同一组内的时间步共享相同的缓存特征。为了实现最优分组，我们提出了动态规划调度（DPS）：</p>
<p>首先，我们考虑两个约束条件：1）每个特征图只属于一个组，确保没有步骤被重复或遗漏；2）每个组内特征图的顺序必须保持不变，以保持去噪过程的时间一致性。具体规定如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G_{1} &=\left\{X_{g}^{0}, X_{g}^{1}, ..., X_{g}^{s_{1}-1}\right\}, \\
G_{2} &=\left\{X_{g}^{s_{1}}, X_{g}^{s_{1}+1}, ..., X_{g}^{s_{2}-1}\right\}, \\
&... \\
G_{K} &=\left\{X_{g}^{s_{K-1}}, X_{g}^{s_{K-1}+1}, ..., X_{g}^{T-1}\right\}
\end{aligned} \tag{3}</script><p>其中，每个组的第一个元素$X_{g}^{s_{*}}$的时间步表示分割点，这些分割点形成了缓存调度。</p>
<p>其次，我们定义组内误差为$D_{k}(i, j)$，它表示当步骤i到j被分配到第k个组时，由缓存和量化引入的误差。值得注意的是，由于$X_{g}^{i}$被缓存并替代$\{X_{g}^{i+1}, …, X_{g}^{j}\}$，误差是通过依次比较$X_{g}^{i}$与$\{X_{g}^{i+1}, …, X_{g}^{j}\}$并将所得差异求和来计算的。此外，量化误差源于特征图之间的绝对数值差异，因此使用L1范数来衡量。因此，$D_{k}(i, j)$的数学表达式如下：</p>
<script type="math/tex; mode=display">
D_{k}(i, j)=\sum_{t=i+1}^{j}\left\|X_{g}^{i}-X_{g}^{t}\right\|_{1} \tag{4}</script><p>第三，我们将T个步骤划分为K个组的划分记为$b(T, K)$。分组损失函数定义为$L[b(T, K)]=\sum_{k=1}^{K} D_{k}(i, j)$。第K个最优组的解可以表示为：</p>
<script type="math/tex; mode=display">
L[b(T, K)] = L[b(s-1, K-1)] + D(s, T) \tag{5}</script><script type="math/tex; mode=display">
M(T, K)=\min _{K \leq s \leq T} L[b(T, K)] \tag{6}</script><p>其中，s表示分割点，$K \leq s \leq T$确保每个特征图只属于一个组，$M(T, K)$最小化分组损失以获得第K个最优组$G_{K} = \{X_{g}^{s}, X_{g}^{s+1}, …, X_{g}^{T-1}\}$。简而言之，上述公式可以重新表述为：</p>
<script type="math/tex; mode=display">
M(T, K)=\min _{K \leq s \leq T}\{M(s-1, K-1)+D(s, T)\} \tag{7}</script><p>可以看出，第K个最优组是基于将s-1个特征图分配到K-1个最优组的基础上得到的。因此，所有最优组都可以基于边界条件$M(t, 1)$通过迭代求解得到。DPS的工作流程如算法1所示。</p>
<p><img src="a1.png" width="50%"></p>
<p>然而，由于嵌套循环，DPS的计算复杂，导致收敛缓慢。我们考虑实际的分组因素，将组长度优化到不超过$2N$且不小于$N/2$。这显著降低了DPS的计算复杂度。例如，在ImageNet上对具有250个步骤的LDM进行求解的时间从4小时减少到8分钟。最后，DPS有效地获得了最小化缓存和量化误差的最优调度。</p>
<h4 id="4-3-解耦误差校正"><a href="#4-3-解耦误差校正" class="headerlink" title="4.3. 解耦误差校正"></a>4.3. 解耦误差校正</h4><p>为了在保持加速效率的同时进一步减轻耦合和累积的误差，我们探索了一种无训练的解决方案。我们首先分析在不同条件下接收缓存特征的块的输出：</p>
<script type="math/tex; mode=display">
O_{g}=X_{g} W_{g}, O_{c}=X_{c} W_{g}, O_{c q}=X_{c q} W_{q} \tag{8}</script><p>其中，$O \in \mathbb{R}^{B \times C^{\circ}}$、$X \in \mathbb{R}^{B \times C^{i}}$和$W \in \mathbb{R}^{C^{i} \times C^{\circ}}$分别表示输出、激活和权重。B、$C^{i}$和$C^{\circ}$分别表示批大小、输入通道维度和输出通道维度。下标g、c和q分别表示不同的条件：真实值、缓存和量化。我们观察到$O_{g}$和$O_{c q}$在通道粒度上具有很强的相关性，如图5(a)所示。因此，我们可以沿着输出通道维度为$O_{c q}$计算校正参数，以减少它们相对于$O_{g}$的误差。并且我们在每个步骤进行校正，以减轻累积误差。校正公式如下：</p>
<script type="math/tex; mode=display">
O_{g}=a \cdot O_{c q}+b \tag{9}</script><p>其中，$a \in \mathbb{R}^{C^{\circ}}$和$b \in \mathbb{R}^{C^{\circ}}$是校正参数。我们使用最小二乘法求解它们。例如，第k个通道的校正参数如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a_{k} &=\frac{\operatorname{Cov}\left(O_{c q(:, k)}, O_{g(:, k)}\right)}{\operatorname{Var}\left(O_{c q(:, k)}\right)} \\
b_{k} &=\overline{O}_{g(:, k)}-a_{k} * \overline{O}_{c q(:, k)}
\end{aligned} \tag{10}</script><p>这里，$\overline{O}_{g(:, k)}$和$\overline{O}_{c q(:, k)}$分别表示第k个输出通道的均值。当使用校正参数调整$O_{c q}$时，尽管消除了均值误差，但误差的方差仍然很大，导致校正效果不佳，如图5(b)(1)和(3)所示。根本问题在于，直接校正$O_{c q}$无法有效消除缓存误差，因为这些误差本质上源于$X_{g}$和$X_{c}$之间的差异。</p>
<p>为了解决这个问题，我们提出了解耦误差校正（DEC），将缓存和量化引入的误差$E_{o}$解耦为缓存误差$E_{c}$和量化误差$E_{q}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& E_{o}=X_{g} W_{g}-X_{c q} W_{q}=O_{g}-O_{c q} \\
& E_{c}=X_{g} W_{g}-X_{c} W_{g}=O_{g}-O_{c} \\
& E_{q}=X_{c} W_{g}-X_{c q} W_{q}=O_{c}-O_{c q}
\end{aligned} \tag{11}</script><p>与式9类似，我们校正$X_{c}$以减少$E_{c}$，校正$O_{c q}$以减少$E_{q}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& X_{g}=a_{1} \cdot X_{c}+b_{1} \\
& O_{c}=a_{2} \cdot O_{c q}+b_{2}
\end{aligned} \tag{12}</script><p>其中，校正参数$(a_{1}, b_{1}) \in \mathbb{R}^{C^{i}}$、$(a_{2}, b_{2}) \in \mathbb{R}^{C^{\circ}}$的求解方式与式10相同。实验结果表明，DEC不仅消除了均值误差，还有效降低了误差方差（如图5(b)(4)所示），显著提高了性能。例如，与直接校正相比，DEC将LDM在ImageNet上的FID分数提高了0.91。</p>
<p>我们还提供了DEC优于直接校正的理论证明。通过等价变换（详细内容见附录9），两种校正方法将$O_{c q}$表示为：</p>
<script type="math/tex; mode=display">
O_{c q}=X_{c q} W_{q}=\frac{X_{g} W_{g}}{a}-\frac{b}{a} \tag{13}</script><script type="math/tex; mode=display">
O_{c q}=X_{c q} W_{q}=\frac{X_{g}}{a_{1}} \cdot \frac{W_{g}}{a_{2}}-\frac{b_{1}}{a_{1}} \cdot \frac{W_{g}}{a_{2}}-\frac{b_{2}}{a_{2}} \tag{14}</script><p>可以看出，与在输出通道上直接校正相比，DEC在输入通道和输出通道上都调整了均值和方差。当假设$a_{1} = 1$且$b_{1} = 0$时，这两个表达式是等价的，这意味着$X_{g}$和$X_{c}$之间的均值误差为零且方差可忽略不计。然而，如图5(b)(2)所示，这种假设显然不成立，因此DEC是更合理的方法。此外，通过将$(a_{2}, b_{2})$融入权重量化中，DEC在网络推理过程中仅额外引入一次矩阵乘法和加法运算。</p>
<h3 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h3><h4 id="5-1-实验设置"><a href="#5-1-实验设置" class="headerlink" title="5.1. 实验设置"></a>5.1. 实验设置</h4><p>模型、数据集和指标。为了证明我们方法的有效性，我们在采用UNet框架的DDPM、LDM和Stable Diffusion [56, 68]以及采用DiT框架的DiT-XL/2 [52]上进行了评估。我们在六个常用数据集上呈现了实验结果：CIFAR-10、LSUN-Bedroom、LSUN-Church、ImageNet、MS-COCO和PartiPrompt [6, 23, 34, 76, 77]。遵循先前的研究 [4, 37, 44, 74]，我们使用MS-COCO的5k验证集和PartiPrompt的1.63k文本描述作为Stable Diffusion的提示词，并为DiT-XL/2生成10k张图像。对于其他任务，我们生成50k张图像来评估生成质量。评估指标包括FID、IS和CLIP分数（基于ViT-g/14）[16, 17, 62]。此外，我们采用Bops（$Bops = MACs \times b_w \times b_x$）、加速比（在GPU上）和模型大小（MB）来展示加速和压缩性能。</p>
<p>缓存和量化设置。我们的方法使用Deepcache [44]、Δ-DiT [4]和EDA-DM [38]作为基线。我们分别选择最后3/1/1个块作为DDPM、LDM和Stable Diffusion模型的缓存块，并保留中间块（[4]中的$I=7$和$N_c=14$）作为DiT-XL/2的缓存对象。对于模型量化，我们利用[37]中的时间量化器对所有层进行量化，对权重采用通道级量化，对激活采用层级量化，这是常见的做法。此外，CacheQuant可以与量化重构无缝集成以提升性能。</p>
<h4 id="5-2-与时间层面方法的比较"><a href="#5-2-与时间层面方法的比较" class="headerlink" title="5.2. 与时间层面方法的比较"></a>5.2. 与时间层面方法的比较</h4><p>扩散模型的主流时间层面加速方法包括模型缓存和快速求解器。我们首先将CacheQuant与基于缓存的方法（Deepcache [44]、Δ-DiT [4]）进行了比较，结果如表2和表3所示。我们的方法实现了与基于缓存的方法相当甚至更优的性能，同时实现了4倍的模型压缩和显著的加速比提升。</p>
<p>此外，如表1所示，CacheQuant对缓存频率表现出稳健性，始终优于其他方法。在较小的缓存频率下，我们的方法甚至实现了比全精度模型更低的FID分数。这在先前的研究中也经常出现 [27, 37, 38]，表明生成的图像质量与全精度模型生成的相当。我们通过将其与PLMS求解器 [36] 进行比较，展示了CacheQuant相对于快速求解器的优越性。如表4所示，以采用50步PLMS的Stable Diffusion为基线，将PLMS步数减少到20步会严重降低性能。相比之下，我们的方法在保持性能的同时，实现了4倍的模型压缩和超过5倍的加速。</p>
<h4 id="5-3-与结构层面方法的比较"><a href="#5-3-与结构层面方法的比较" class="headerlink" title="5.3. 与结构层面方法的比较"></a>5.3. 与结构层面方法的比较</h4><p>结构层面的加速方法主要包括模型量化、剪枝和蒸馏。我们在表2中将CacheQuant与基于量化的方法（EDA-DM [38]）进行了比较。在8位精度下，缓存频率$N=5$的CacheQuant优于EDA-DM（FID分别为4.03和4.13）。重要的是，CacheQuant避免了昂贵的再训练，并实现了显著的加速比提升（加速比分别为7.87倍和1.91倍）。随着位宽的减小，4位精度的EDA-DM实现了8倍的压缩和3.35倍的加速，但FID分数显著下降到44.12。与之形成鲜明对比的是，结合重构的CacheQuant保持了12.65的FID分数，实现了8倍的压缩和18.06倍的加速。我们在表2中与基于剪枝的方法进行了比较。可以看出，CacheQuant在效率、性能、加速和压缩方面都优于Diff-Pruning [9]。我们还将CacheQuant与基于蒸馏的方法进行了比较，包括Small SD [39]和BK-SDM [21]，这些方法通过在LAION [64]数据集上再训练，以Stable Diffusion为基线开发而成。如表4所示，我们的方法与这些方法相比，实现了更优的性能和更快的加速。</p>
<h4 id="5-4-分析"><a href="#5-4-分析" class="headerlink" title="5.4. 分析"></a>5.4. 分析</h4><p>消融研究。为了评估每个提出的组件的有效性，我们在ImageNet上使用具有250步DDIM的LDM-4模型进行了全面的消融研究，结果如表5所示。我们将8位量化添加到缓存频率$N=20$的DeepCache中作为基线，导致FID分数增加到15.36。引入DPS来选择最优缓存调度后，FID分数显著提高到8.47。这表明DPS有效地最小化了缓存和量化引起的误差。通过进一步结合以无训练方式校正解耦误差的DEC，FID分数提高到7.21。此外，我们的方法与重构方法相结合，进一步提升了性能，显著将IS分数提高到180.42。</p>
<p>加速与性能的权衡。我们研究了各种方法在加速与性能之间的权衡，结果如图6所示。随着加速比的增加，传统的加速方法，如缓存（Deepcache）、量化（EDA-DM）和求解器（PLMS），都出现了显著的性能下降。与之形成鲜明对比的是，我们的方法在两个层面全面加速扩散模型，在进一步突破加速极限的同时保持了性能。详细的实验设置见附录10。</p>
<p>效率研究。如图7所示，我们的方法在效率上显著优于传统方法。例如，基于压缩的方法需要超过10小时的GPU运行时间，而基于蒸馏的方法则需要超过10天才能完成。</p>
<p>加速模型的部署。为了评估实际应用中的加速效果，我们在各种硬件平台上部署了加速后的扩散模型。如图8所示，在GPU上的加速效果明显优于在CPU和ARM上的加速效果。我们的方法在MS-COCO上实现了Stable Diffusion的5倍GPU加速，显著促进了其在实际场景中的应用。</p>
<h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h3><p>在本文中，我们提出了CacheQuant，这是一种新颖的无训练范式，可在时间和结构两个层面全面加速扩散模型。为解决优化的非正交性问题，我们提出了动态规划调度（DPS），通过选择最优缓存调度来最小化缓存和量化带来的误差。此外，我们采用了解耦误差校正（DEC），在无需任何再训练的情况下进一步减轻耦合和累积的误差。在多个数据集和不同模型框架上的实证评估表明，CacheQuant优于传统的加速方法。重要的是，所提出的范式在保持性能的同时突破了扩散模型的加速极限，从而为该领域提供了新的视角。</p>
<h3 id="CacheQuant：全面加速的扩散模型补充材料"><a href="#CacheQuant：全面加速的扩散模型补充材料" class="headerlink" title="CacheQuant：全面加速的扩散模型补充材料"></a>CacheQuant：全面加速的扩散模型补充材料</h3><h4 id="8-详细的实验实现"><a href="#8-详细的实验实现" class="headerlink" title="8. 详细的实验实现"></a>8. 详细的实验实现</h4><p>我们使用来自官方网站的DiT-XL/2¹、DDIMs²和LDMs³的预训练模型。对于Stable Diffusion，我们使用CompVis代码库⁴及其v1.4检查点。条件生成模型由一个扩散模型和一个解码器模型组成。与先前的工作[27, 38, 74]一样，我们只关注扩散模型，不对解码器模型进行量化。在重构训练中，所有实验的校准样本数设置为1024，训练批次大小设置为32。然而，对于Stable Diffusion，由于时间和内存资源限制，我们将重构校准样本数调整为512，训练批次大小调整为4。我们使用开源工具pytorch-OpCounter⁵来计算量化前后模型的大小和Bops。并且，按照量化设置，我们只计算扩散模型部分，不包括解码器和编码器部分。我们使用ADM的TensorFlow评估套件guided-diffusion⁶来评估FID和IS，使用开源代码clip-score⁷来评估CLIP分数。加速后的扩散模型通过利用CUTLASS⁸和PyTorch⁹进行部署。加速比是通过在RTX 3090上测量生成单张图像所需的时间来计算的。按照标准做法[37, 38, 50]，我们采用零样本方法在COCO-val上评估Stable Diffusion，将生成的512×512图像和验证图像resize为300×300，并进行中心裁剪，以评估FID和IS分数。</p>
<h4 id="9-用两种校正方法表示-X-cq-W-q"><a href="#9-用两种校正方法表示-X-cq-W-q" class="headerlink" title="9. 用两种校正方法表示$X_{cq}W_q$"></a>9. 用两种校正方法表示$X_{cq}W_q$</h4><p>基于式8和式9，直接校正简单地将$X_{cq}W_q$表示为：</p>
<script type="math/tex; mode=display">X_{cq}W_q=\frac{X_gW_g}{a}-\frac{b}{a}\tag{15}</script><p>我们的方法分别对$X_c$和$O_{cq}$进行校正。基于式8和式9，推导得到方程：</p>
<script type="math/tex; mode=display">X_c=\frac{X_g}{a_1}-\frac{b_1}{a_1}\tag{16}</script><script type="math/tex; mode=display">X_{cq}W_q=\frac{X_cW_g}{a_2}-\frac{b_2}{a_2}\tag{17}</script><p>此外，$X_{cq}W_q$的表达式为：</p>
<script type="math/tex; mode=display">X_{cq}W_q=\frac{X_g}{a_1}\cdot\frac{W_g}{a_2}-\frac{b_1}{a_1}\cdot\frac{W_g}{a_2}-\frac{b_2}{a_2}\tag{18}</script><p>由于校正参数$(a,b)\in\mathbb{R}^{C^\circ}$，$(a_1,b_1)\in\mathbb{R}^{C^i}$，$(a_2,b_2)\in\mathbb{R}^{C^\circ}$，因此当且仅当$a_1 = 1$且$b_1=0$时，$X_{cq}W_q$的两种表示形式才等价。</p>
<h4 id="10-加速与性能权衡评估的实验设置"><a href="#10-加速与性能权衡评估的实验设置" class="headerlink" title="10. 加速与性能权衡评估的实验设置"></a>10. 加速与性能权衡评估的实验设置</h4><p>我们在5.4节评估了各种方法在加速与性能之间的权衡。图6中的详细实验设置和结果如表6和表7所示。</p>
<h4 id="11-生成结果的比较"><a href="#11-生成结果的比较" class="headerlink" title="11. 生成结果的比较"></a>11. 生成结果的比较</h4><p>在本节中，我们展示了来自原始模型和其他加速方法的随机样本，这些样本具有固定的随机种子。我们的方法保持8位精度。我们在图9和图10中可视化了不同方法生成的图像质量和延迟。</p>
<h4 id="12-局限性和未来工作"><a href="#12-局限性和未来工作" class="headerlink" title="12. 局限性和未来工作"></a>12. 局限性和未来工作</h4><p>虽然CacheQuant在8位精度下以无训练方式取得了显著成果，但在W4A8精度下需要依赖重构来恢复性能。未来，我们将进一步改进CacheQuant，以提高其与W4A8精度的兼容性。</p>
<h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><h3 id="加速原理"><a href="#加速原理" class="headerlink" title="加速原理"></a>加速原理</h3><ul>
<li>当前的加速方法主要有时间层面的加速（更大的步长）和结构层面的加速（更小的网络）。</li>
<li>本文将提出一种无训练的加速方法，集合了两种类型的加速方法。该方法基于模型缓存和量化。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/diffusion/" rel="tag"># diffusion</a>
              <a href="/tags/CVPR/" rel="tag"># CVPR</a>
              <a href="/tags/2025/" rel="tag"># 2025</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/08/2025-CVPR-BlockDance-Reuse-Structurally-Similar-Spatio-Temporal-Features-to-Accelerate-Diffusion-Transformers%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" rel="prev" title="2025-CVPR-BlockDance Reuse Structurally Similar Spatio-Temporal Features to Accelerate Diffusion Transformers论文精读">
      <i class="fa fa-chevron-left"></i> 2025-CVPR-BlockDance Reuse Structurally Similar Spatio-Temporal Features to Accelerate Diffusion Transformers论文精读
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/07/10/2025-CVPR-DreamCache-Finetuning-Free-Lightweight-Personalized-Image-Generation-via-Feature-Caching%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" rel="next" title="2025-CVPR-DreamCache Finetuning-Free Lightweight Personalized Image Generation via Feature Caching论文精读">
      2025-CVPR-DreamCache Finetuning-Free Lightweight Personalized Image Generation via Feature Caching论文精读 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E7%BF%BB%E8%AF%91"><span class="nav-number">1.</span> <span class="nav-text">全文翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%95%E8%A8%80"><span class="nav-number">1.2.</span> <span class="nav-text">1. 引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">2. 相关工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-number">1.4.</span> <span class="nav-text">3. 预备知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-CacheQuant"><span class="nav-number">1.5.</span> <span class="nav-text">4. CacheQuant</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E7%BB%BC%E5%90%88%E5%8A%A0%E9%80%9F%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1. 综合加速的挑战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B0%83%E5%BA%A6"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2. 动态规划调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E8%A7%A3%E8%80%A6%E8%AF%AF%E5%B7%AE%E6%A0%A1%E6%AD%A3"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3. 解耦误差校正</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.6.</span> <span class="nav-text">5. 实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1. 实验设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E4%B8%8E%E6%97%B6%E9%97%B4%E5%B1%82%E9%9D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2. 与时间层面方法的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E4%B8%8E%E7%BB%93%E6%9E%84%E5%B1%82%E9%9D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3. 与结构层面方法的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E5%88%86%E6%9E%90"><span class="nav-number">1.6.4.</span> <span class="nav-text">5.4. 分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA"><span class="nav-number">1.7.</span> <span class="nav-text">6. 结论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CacheQuant%EF%BC%9A%E5%85%A8%E9%9D%A2%E5%8A%A0%E9%80%9F%E7%9A%84%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E8%A1%A5%E5%85%85%E6%9D%90%E6%96%99"><span class="nav-number">1.8.</span> <span class="nav-text">CacheQuant：全面加速的扩散模型补充材料</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E8%AF%A6%E7%BB%86%E7%9A%84%E5%AE%9E%E9%AA%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.1.</span> <span class="nav-text">8. 详细的实验实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%A0%A1%E6%AD%A3%E6%96%B9%E6%B3%95%E8%A1%A8%E7%A4%BA-X-cq-W-q"><span class="nav-number">1.8.2.</span> <span class="nav-text">9. 用两种校正方法表示$X_{cq}W_q$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E5%8A%A0%E9%80%9F%E4%B8%8E%E6%80%A7%E8%83%BD%E6%9D%83%E8%A1%A1%E8%AF%84%E4%BC%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.8.3.</span> <span class="nav-text">10. 加速与性能权衡评估的实验设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.8.4.</span> <span class="nav-text">11. 生成结果的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E5%B1%80%E9%99%90%E6%80%A7%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.8.5.</span> <span class="nav-text">12. 局限性和未来工作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">文章总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">加速原理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zongqing Li"
      src="https://github.com/hqulzq/hqulzq.github.io/blob/main/images/userimg.jpg?raw=true">
  <p class="site-author-name" itemprop="name">Zongqing Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hqulzq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hqulzq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hqulzq@163.com" title="E-Mail → mailto:hqulzq@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2019/" rel="tag">2019</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2020/" rel="tag">2020</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2021/" rel="tag">2021</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2022/" rel="tag">2022</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2023/" rel="tag">2023</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2024/" rel="tag">2024</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2025/" rel="tag">2025</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bug%E6%80%BB%E7%BB%93/" rel="tag">Bug总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CVPR/" rel="tag">CVPR</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CVPR-Workshop/" rel="tag">CVPR Workshop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICCV/" rel="tag">ICCV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICLR/" rel="tag">ICLR</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICML/" rel="tag">ICML</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IJCAI/" rel="tag">IJCAI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Knife4j/" rel="tag">Knife4j</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MinIO/" rel="tag">MinIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis-Plus/" rel="tag">Mybatis-Plus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NeurIPS/" rel="tag">NeurIPS</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ODE%E6%B1%82%E8%A7%A3/" rel="tag">ODE求解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/diffusion/" rel="tag">diffusion</a><span class="tag-list-count">62</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/latex/" rel="tag">latex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" rel="tag">代码随想录</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%B4%E5%87%BD%E6%95%B0/" rel="tag">头函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E5%BA%AD%E5%85%AC%E5%AF%93/" rel="tag">尚庭公寓</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" rel="tag">异常处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" rel="tag">快速入门</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" rel="tag">技术总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%AB%99/" rel="tag">网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%A5%E4%BE%9D/" rel="tag">若依</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87/" rel="tag">论文</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8i/" rel="tag">链表i</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" rel="tag">项目实战</a><span class="tag-list-count">6</span></li></ul>
        </canvas>
    </div>
</div>



    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zongqing Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #4D4D4C;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #F7F7F7;
      background-image: linear-gradient(#F7F7F7, #F7F7F7);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>

  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('post.copy_button').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('post.copy_success')
          else $(this).text('post.copy_failure')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('post.copy_button')
        }, 300)
      }).append(e)
    })
  </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
